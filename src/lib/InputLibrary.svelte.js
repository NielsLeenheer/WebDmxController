/**
 * InputLibrary - Reactive Svelte 5 library for managing inputs
 *
 * Extends Library base class with input-specific functionality.
 * Stores inputs as plain objects (not class instances) for proper reactivity.
 */

import { Library } from './Library.svelte.js';
import { isButton, hasValues } from './inputs/utils.js';
import { toCSSIdentifier } from './css/utils.js';
import { getInputExportedValues } from './inputs/valueTypes.js';

export class InputLibrary extends Library {
	constructor() {
		super('dmx-inputs');
	}

	/**
	 * Create and add a new input
	 * @param {Object} config - Input configuration
	 * @returns {Object} Created input object
	 */
	create(config = {}) {
		const name = config.name || 'Untitled Input';
		const buttonMode = config.buttonMode || 'momentary';

		const input = {
			// id will be auto-generated by base class
			name,
			deviceId: config.deviceId || null,
			deviceName: config.deviceName || null,
			controlId: config.controlId || null,
			controlName: config.controlName || null,
			color: config.color || null,
			type: config.type || 'knob',
			colorSupport: config.colorSupport || 'none',
			orientation: config.orientation || null,
			deviceBrand: config.deviceBrand || null,
			buttonMode,
			cssIdentifier: config.cssIdentifier || toCSSIdentifier(name),
			order: this.items.length
		};

		return this.add(input);
	}

	/**
	 * Update an input's CSS identifier when name changes
	 * @param {string} id - Input ID
	 * @param {Object} updates - Properties to update
	 * @returns {boolean} Success status
	 */
	update(id, updates) {
		// Update CSS identifier if name changed
		if (updates.name !== undefined) {
			updates.cssIdentifier = toCSSIdentifier(updates.name);
		}

		return super.update(id, updates);
	}

	/**
	 * Find input by device and control ID
	 * @param {string} deviceId - Device ID
	 * @param {string} controlId - Control ID
	 */
	findByDeviceControl(deviceId, controlId) {
		return this.items.find(i =>
			i.deviceId === deviceId && i.controlId === controlId
		);
	}

	/**
	 * Get exported values for an input
	 * Returns array of value definitions that can be mapped to controls
	 * @param {string} inputId - Input ID
	 * @returns {Array} Array of exported value definitions
	 */
	getExportedValues(inputId) {
		const input = this.get(inputId);
		if (!input) return [];
		return getInputExportedValues(input);
	}

	/**
	 * Get all inputs that export values (not just button states)
	 * These are inputs suitable for value-based triggers
	 * @returns {Array} Array of inputs with exportable values
	 */
	getValueInputs() {
		return this.items.filter(input => hasValues(input));
	}

	/**
	 * Detect device brand from device name for backward compatibility
	 * @param {string} deviceName - The device name
	 * @returns {string|null} Detected brand or null
	 */
	_detectDeviceBrandFromName(deviceName) {
		if (!deviceName) return null;
		
		// Sony patterns
		if (/dualshock|dualsense|playstation|sony|ps[3-5]/i.test(deviceName)) {
			return 'sony';
		}
		// Nintendo patterns
		if (/nintendo|switch|pro\s*controller|joy-?con/i.test(deviceName)) {
			return 'nintendo';
		}
		// Default to xbox for other gamepads
		return 'xbox';
	}

	/**
	 * Deserialize input data from storage
	 * @param {Object} inputData - Serialized input data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(inputData, index) {
		// Handle backward compatibility
		const inputType = inputData.type || (isButton({ controlId: inputData.controlId || inputData.inputControlId }) ? 'button' : 'knob');
		const name = inputData.name || 'Untitled Input';

		// Migrate from old cssProperty (--name) to cssIdentifier (name)
		let cssIdentifier = inputData.cssIdentifier;
		if (!cssIdentifier && inputData.cssProperty) {
			// Remove leading -- from cssProperty
			cssIdentifier = inputData.cssProperty.replace(/^--/, '');
		}
		if (!cssIdentifier) {
			cssIdentifier = toCSSIdentifier(name);
		}

		// Detect device brand from device name if not stored (backward compatibility)
		const deviceId = inputData.deviceId || inputData.inputDeviceId || null;
		const deviceName = inputData.deviceName || inputData.inputDeviceName || null;
		let deviceBrand = inputData.deviceBrand || inputData.gamepadBrand || null;
		if (!deviceBrand && deviceId?.startsWith('gamepad-')) {
			deviceBrand = this._detectDeviceBrandFromName(deviceName);
		}

		return {
			id: inputData.id || crypto.randomUUID(),
			name: name,
			deviceId: deviceId,
			deviceName: deviceName,
			controlId: inputData.controlId || inputData.inputControlId || null,
			controlName: inputData.controlName || inputData.inputControlName || inputData.friendlyName || null,
			color: inputData.color || null,
			type: inputType,
			colorSupport: inputData.colorSupport || (inputData.supportsColor ? 'rgb' : 'none'),
			orientation: inputData.orientation || null,
			deviceBrand: deviceBrand,
			buttonMode: inputData.buttonMode || 'momentary',
			cssIdentifier,
			order: inputData.order !== undefined ? inputData.order : index
		};
	}
}
