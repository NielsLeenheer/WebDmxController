/**
 * InputLibrary - Reactive Svelte 5 library for managing inputs
 *
 * Extends Library base class with input-specific functionality.
 * Stores inputs as plain objects (not class instances) for proper reactivity.
 */

import { Library } from './Library.svelte.js';
import { hasValues } from './inputs/utils.js';
import { toUniqueCSSIdentifier } from './css/utils.js';
import { InputColorManager } from './inputs/InputColorManager.js';

export class InputLibrary extends Library {
	// Internal color manager for tracking color assignments per device
	// NOTE: Do NOT use a field initializer here! Field initializers run AFTER super()
	// returns, which would overwrite the color manager created during load().

	/**
	 * Get the color manager, initializing it if needed
	 */
	_getColorManager() {
		if (!this._colorManager) {
			this._colorManager = new InputColorManager();
		}
		return this._colorManager;
	}

	constructor() {
		super('dmx-inputs');
	}

	/**
	 * Override load to rebuild color usage after loading from storage
	 */
	load() {
		super.load();
		const colorManager = this._getColorManager();
		colorManager.rebuildFromInputs(this.items);
	}

	/**
	 * Create and add a new input
	 * Auto-assigns a color if the control supports colors and no color is provided
	 * @param {Object} config - Input configuration
	 * @returns {Object} Created input object
	 */
	create(config = {}) {
		const name = config.name || 'Untitled Input';
		const buttonMode = config.buttonMode || 'momentary';
		const colorSupport = config.colorSupport || 'none';
		const deviceId = config.deviceId || null;
		const controlId = config.controlId || null;

		// Auto-assign color if not provided and control supports colors
		let color = config.color;
		if (!color && colorSupport && colorSupport !== 'none') {
			color = this._getColorManager().getNextColor(deviceId, colorSupport);
		}

		// Get existing CSS identifiers for uniqueness check
		const existingIdentifiers = this.items.map(i => i.cssIdentifier);

		const input = {
			// id will be auto-generated by base class
			name,
			deviceId,
			deviceName: config.deviceName || null,
			controlId,
			controlName: config.controlName || null,
			color,
			type: config.type || 'knob',
			colorSupport,
			orientation: config.orientation || null,
			deviceBrand: config.deviceBrand || null,
			buttonMode,
			cssIdentifier: config.cssIdentifier || toUniqueCSSIdentifier(name, existingIdentifiers),
			order: this.items.length
		};

		const created = this.add(input);

		// Register color usage after adding
		if (created.color && deviceId) {
			this._getColorManager().registerColor(deviceId, created.color);
		}

		return created;
	}

	/**
	 * Update an input
	 * Handles CSS identifier updates and color tracking
	 * @param {string} id - Input ID
	 * @param {Object} updates - Properties to update
	 * @returns {boolean} Success status
	 */
	update(id, updates) {
		const existing = this.get(id);
		if (!existing) return false;

		// Update CSS identifier if name changed
		if (updates.name !== undefined) {
			// Get existing identifiers, excluding this input's current identifier
			const existingIdentifiers = this.items.map(i => i.cssIdentifier);
			const getIdentifierForId = (inputId) => this.get(inputId)?.cssIdentifier;
			updates.cssIdentifier = toUniqueCSSIdentifier(updates.name, existingIdentifiers, id, getIdentifierForId);
		}

		// Handle color changes - update color manager
		if (updates.color !== undefined && updates.color !== existing.color) {
			// Release old color
			if (existing.color) {
				this._getColorManager().releaseColor(existing.deviceId, existing.color);
			}
			// Register new color
			if (updates.color) {
				this._getColorManager().registerColor(existing.deviceId, updates.color);
			}
		}

		return super.update(id, updates);
	}

	/**
	 * Remove an input
	 * Releases color from color manager
	 * @param {string} id - Input ID
	 * @returns {boolean} Success status
	 */
	remove(id) {
		const input = this.get(id);
		if (!input) return false;

		// Release color before removing
		if (input.color && input.deviceId) {
			this._getColorManager().releaseColor(input.deviceId, input.color);
		}

		return super.remove(id);
	}

	/**
	 * Find input by device and control ID
	 * @param {string} deviceId - Device ID
	 * @param {string} controlId - Control ID
	 */
	findByDeviceControl(deviceId, controlId) {
		return this.items.find(i =>
			i.deviceId === deviceId && i.controlId === controlId
		);
	}

	/**
	 * Get all inputs that export values (not just button states)
	 * These are inputs suitable for value-based triggers
	 * @returns {Array} Array of inputs with exportable values
	 */
	getValueInputs() {
		return this.items.filter(input => hasValues(input));
	}

	/**
	 * Get the next available color for a device
	 * Useful when manually assigning colors (e.g., for Thingy devices)
	 * @param {string} deviceId - The device ID
	 * @param {string} colorSupport - Color support type: 'rgb', 'red', 'green', 'none'
	 * @returns {string|null} The next available color name
	 */
	getNextColor(deviceId, colorSupport = 'rgb') {
		return this._getColorManager().getNextColor(deviceId, colorSupport);
	}

	/**
	 * Deserialize input data from storage
	 * @param {Object} inputData - Serialized input data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(inputData, index) {
		return {
			id: inputData.id,
			name: inputData.name,
			deviceId: inputData.deviceId || null,
			deviceName: inputData.deviceName || null,
			controlId: inputData.controlId || null,
			controlName: inputData.controlName || null,
			color: inputData.color || null,
			type: inputData.type,
			colorSupport: inputData.colorSupport || 'none',
			orientation: inputData.orientation || null,
			deviceBrand: inputData.deviceBrand || null,
			buttonMode: inputData.buttonMode || 'momentary',
			cssIdentifier: inputData.cssIdentifier,
			order: inputData.order !== undefined ? inputData.order : index
		};
	}
}
