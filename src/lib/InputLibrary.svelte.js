/**
 * InputLibrary - Reactive Svelte 5 library for managing inputs
 *
 * Extends Library base class with input-specific functionality.
 * Stores inputs as plain objects (not class instances) for proper reactivity.
 */

import { Library } from './Library.svelte.js';
import { isButtonInput, isContinuousInput } from './inputs/utils.js';
import { toCSSIdentifier } from './css/utils.js';
import { getInputExportedValues } from './inputs/valueTypes.js';

export class InputLibrary extends Library {
	constructor() {
		super('dmx-inputs');
	}

	/**
	 * Create and add a new input
	 * @param {Object} config - Input configuration
	 * @returns {Object} Created input object
	 */
	create(config = {}) {
		const name = config.name || 'Untitled Input';
		const buttonMode = config.buttonMode || 'momentary';

		// Use type field to determine input capabilities
		// Some inputs (like thingy) have both button AND continuous functionality
		const tempInput = { type: config.type, inputControlId: config.inputControlId };
		const hasButton = isButtonInput(tempInput);
		const hasContinuous = isContinuousInput(tempInput);

		// Generate CSS identifiers
		let cssClassOn = null;
		let cssClassOff = null;
		let cssClassDown = null;
		let cssClassUp = null;
		let cssProperty = null;

		// Button CSS classes (if input has button functionality)
		if (hasButton) {
			if (buttonMode === 'toggle') {
				cssClassOn = config.cssClassOn || `${toCSSIdentifier(name)}-on`;
				cssClassOff = config.cssClassOff || `${toCSSIdentifier(name)}-off`;
			} else {
				cssClassDown = config.cssClassDown || `${toCSSIdentifier(name)}-down`;
				cssClassUp = config.cssClassUp || `${toCSSIdentifier(name)}-up`;
			}
		}

		// CSS property base (if input has continuous values)
		if (hasContinuous) {
			cssProperty = config.cssProperty || `--${toCSSIdentifier(name)}`;
		}

		const input = {
			// id will be auto-generated by base class
			name,
			inputDeviceId: config.inputDeviceId || null,
			inputControlId: config.inputControlId || null,
			inputDeviceName: config.inputDeviceName || null,
			color: config.color || null,
			type: config.type || (hasButton ? 'button' : 'knob'),
			colorSupport: config.colorSupport || 'none',
			friendlyName: config.friendlyName || null,
			orientation: config.orientation || null,
			buttonMode,
			cssClassOn,
			cssClassOff,
			cssClassDown,
			cssClassUp,
			cssProperty,
			order: this.items.length
		};

		return this.add(input);
	}

	/**
	 * Update an input's CSS identifiers when name or button mode changes
	 * @param {string} id - Input ID
	 * @param {Object} updates - Properties to update
	 * @returns {boolean} Success status
	 */
	update(id, updates) {
		// Update CSS identifiers if name or buttonMode changed
		if (updates.name !== undefined || updates.buttonMode !== undefined) {
			const input = this.get(id);
			if (!input) return false;
			
			// Apply updates temporarily to generate CSS identifiers
			Object.assign(input, updates);
			this.updateCSSIdentifiers(input);
		}

		return super.update(id, updates);
	}

	/**
	 * Find input by device and control ID
	 * @param {string} deviceId - Device ID
	 * @param {string} controlId - Control ID
	 */
	findByDeviceControl(deviceId, controlId) {
		return this.items.find(i =>
			i.inputDeviceId === deviceId && i.inputControlId === controlId
		);
	}

	/**
	 * Update CSS identifiers for an input based on its name and button mode
	 * @param {Object} input - Input object
	 */
	updateCSSIdentifiers(input) {
		const hasButton = isButtonInput(input);
		const hasContinuous = isContinuousInput(input);

		// Update button CSS classes
		if (hasButton) {
			if (input.buttonMode === 'toggle') {
				input.cssClassOn = `${toCSSIdentifier(input.name)}-on`;
				input.cssClassOff = `${toCSSIdentifier(input.name)}-off`;
				input.cssClassDown = null;
				input.cssClassUp = null;
			} else {
				input.cssClassDown = `${toCSSIdentifier(input.name)}-down`;
				input.cssClassUp = `${toCSSIdentifier(input.name)}-up`;
				input.cssClassOn = null;
				input.cssClassOff = null;
			}
		} else {
			input.cssClassDown = null;
			input.cssClassUp = null;
			input.cssClassOn = null;
			input.cssClassOff = null;
		}

		// Update CSS property base (for continuous values)
		if (hasContinuous) {
			input.cssProperty = `--${toCSSIdentifier(input.name)}`;
		} else {
			input.cssProperty = null;
		}

		this.save();
	}

	/**
	 * Get exported values for an input
	 * Returns array of value definitions that can be mapped to controls
	 * @param {string} inputId - Input ID
	 * @returns {Array} Array of exported value definitions
	 */
	getExportedValues(inputId) {
		const input = this.get(inputId);
		if (!input) return [];
		return getInputExportedValues(input);
	}

	/**
	 * Get all inputs that export continuous values (not just button states)
	 * These are inputs suitable for value-based triggers
	 * @returns {Array} Array of inputs with exportable values
	 */
	getValueInputs() {
		return this.items.filter(input => {
			// Use InputType to check for continuous values
			return isContinuousInput(input);
		});
	}

	/**
	 * Deserialize input data from storage
	 * @param {Object} inputData - Serialized input data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(inputData, index) {
		// Handle backward compatibility - just ensure all properties are present
		// For old inputs without type/supportsColor, detect from inputControlId
		const isButton = inputData.type ?
			['button', 'pad'].includes(inputData.type) :
			isButtonInput({ inputControlId: inputData.inputControlId });

		return {
			id: inputData.id || crypto.randomUUID(), // Generate UUID if not present
			name: inputData.name || 'Untitled Input',
			inputDeviceId: inputData.inputDeviceId || null,
			inputControlId: inputData.inputControlId || null,
			inputDeviceName: inputData.inputDeviceName || null,
			color: inputData.color || null,
			type: inputData.type || (isButton ? 'button' : 'knob'), // NEW: backward compat
			colorSupport: inputData.colorSupport || (inputData.supportsColor ? 'rgb' : 'none'), // NEW: migrate from supportsColor
			friendlyName: inputData.friendlyName || null, // NEW
			buttonMode: inputData.buttonMode || 'momentary',
			cssClassOn: inputData.cssClassOn || null,
			cssClassOff: inputData.cssClassOff || null,
			cssClassDown: inputData.cssClassDown || null,
			cssClassUp: inputData.cssClassUp || null,
			cssProperty: inputData.cssProperty || null,
			order: inputData.order !== undefined ? inputData.order : index
		};
	}
}
