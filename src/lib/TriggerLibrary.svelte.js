/**
 * TriggerLibrary - Reactive Svelte 5 library for managing triggers
 *
 * Extends Library base class with trigger-specific functionality.
 * Stores triggers as plain objects (not class instances) for proper reactivity.
 */

import { Library } from './Library.svelte.js';
import { generateCSSTriggers } from './triggers/css.js';

export class TriggerLibrary extends Library {
	constructor() {
		super('dmx-triggers');
	}

	/**
	 * Create and add a new trigger
	 * @param {Object} config - Trigger configuration
	 * @returns {Object} Created trigger object
	 */
	create(config = {}) {
		const triggerType = config.triggerType || 'pressed';
		const actionType = config.actionType || 'animation';

		const trigger = {
			// id will be auto-generated by base class
			triggerType,
			inputId: config.inputId || null, // Links to InputLibrary item
			actionType,
			deviceId: config.deviceId || null, // Single device for both animation and values
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: config.animation?.id || null,
				duration: config.animation?.duration || 1000,
				easing: config.animation?.easing || 'linear',
				iterations: config.animation?.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			values: actionType === 'values' ? {
				channelValues: config.values?.channelValues || {},
				enabledControls: config.values?.enabledControls || []
			} : null,
			order: this.items.length
		};

		return this.add(trigger);
	}


	/**
	 * Generate CSS for all triggers
	 * @param {Array} devices - Array of device objects
	 * @param {Object} animationLibrary - AnimationLibrary instance to resolve animation cssNames
	 * @param {Object} inputLibrary - InputLibrary instance to resolve input names
	 * @returns {string} Combined CSS
	 */
	toCSS(devices = [], animationLibrary = null, inputLibrary = null) {
		const allTriggers = this.getAll();
		
		// Get unique device IDs that are used in triggers
		const deviceIds = new Set(allTriggers.map(t => t.deviceId).filter(id => id));
		
		// Generate CSS for each device
		const cssRules = [];
		for (const deviceId of deviceIds) {
			const device = devices.find(d => d.id === deviceId);
			if (!device) continue;
			
			const css = generateCSSTriggers(device, allTriggers, animationLibrary, inputLibrary);
			if (css) cssRules.push(css);
		}
		
		return cssRules.join('\n\n');
	}	/**
	 * Deserialize trigger data from storage
	 * @param {Object} triggerData - Serialized trigger data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(triggerData, index) {
		const actionType = triggerData.actionType || 'animation';
		
		return {
			id: triggerData.id || crypto.randomUUID(),
			triggerType: triggerData.triggerType,
			inputId: triggerData.inputId,
			actionType,
			deviceId: triggerData.deviceId,
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: triggerData.animation?.id || triggerData.animationName || null, // Support old animationName
				duration: triggerData.animation?.duration || triggerData.duration || 1000,
				easing: triggerData.animation?.easing || triggerData.easing || 'linear',
				iterations: triggerData.animation?.iterations || triggerData.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			values: actionType === 'values' ? {
				channelValues: triggerData.values?.channelValues || triggerData.channelValues || {},
				enabledControls: triggerData.values?.enabledControls || triggerData.enabledControls || []
			} : null,
			order: triggerData.order !== undefined ? triggerData.order : index
		};
	}
}