/**
 * TriggerLibrary - Reactive Svelte 5 library for managing triggers
 *
 * Extends Library base class with trigger-specific functionality.
 * Stores triggers as plain objects (not class instances) for proper reactivity.
 */

import { Library } from './Library.svelte.js';
import { toCSS } from './triggers/utils.js';

export class TriggerLibrary extends Library {
	constructor() {
		super('webdmx-triggers');
	}

	/**
	 * Create and add a new trigger
	 * @param {Object} config - Trigger configuration
	 * @returns {Object} Created trigger object
	 */
	create(config = {}) {
		const triggerType = config.triggerType || 'pressed';
		const actionType = config.actionType || 'animation';

		const trigger = {
			// id will be auto-generated by base class
			triggerType,
			inputId: config.inputId || null, // Links to InputLibrary item
			actionType,
			deviceId: config.deviceId || null, // Single device for both animation and values
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: config.animation?.id || null,
				duration: config.animation?.duration || 1000,
				easing: config.animation?.easing || 'linear',
				iterations: config.animation?.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			values: actionType === 'values' ? {
				channelValues: config.values?.channelValues || {},
				enabledControls: config.values?.enabledControls || []
			} : null,
			order: this.items.length
		};

		return this.add(trigger);
	}


	/**
	 * Generate CSS for all triggers
	 * @param {Array} devices - Array of device objects
	 * @param {Object} animationLibrary - AnimationLibrary instance to resolve animation cssNames
	 * @param {Object} inputLibrary - InputLibrary instance to resolve input names
	 * @returns {string} Combined CSS
	 */
	toCSS(devices = [], animationLibrary = null, inputLibrary = null) {
		const allTriggers = this.getAll();
		const cssRules = [];

		// Group automatic animation triggers by device to combine them
		const automaticAnimationsByDevice = new Map(); // deviceId -> array of triggers

		// Separate automatic animations from other triggers
		const automaticAnimations = [];
		const otherTriggers = [];

		for (const trigger of allTriggers) {
			if (trigger.actionType === 'animation' &&
			    trigger.triggerType === 'always' &&
			    trigger.animation?.id) {
				automaticAnimations.push(trigger);
			} else {
				otherTriggers.push(trigger);
			}
		}

		// Group automatic animations by device
		for (const trigger of automaticAnimations) {
			const deviceId = trigger.deviceId;
			if (deviceId) {
				if (!automaticAnimationsByDevice.has(deviceId)) {
					automaticAnimationsByDevice.set(deviceId, []);
				}
				automaticAnimationsByDevice.get(deviceId).push(trigger);
			}
		}

		// Generate combined CSS for automatic animations
		for (const [deviceId, triggers] of automaticAnimationsByDevice.entries()) {
			const device = devices.find(d => d.id === deviceId);
			if (!device) continue;

			// Combine all automatic animations for this device
			const animationSpecs = triggers.map(trigger => {
				const iterVal = trigger.animation.iterations === 'infinite' ? 'infinite' : trigger.animation.iterations;
				const durSec = (trigger.animation.duration / 1000).toFixed(3);
				// Look up animation to get cssName
				const animation = animationLibrary?.get(trigger.animation.id);
				const animName = animation?.cssName || trigger.animation.id;
				return `${animName} ${durSec}s ${trigger.animation.easing} ${iterVal}`;
			});

			const animationValue = animationSpecs.join(', ');
			cssRules.push(`#${device.cssId} {
  animation: ${animationValue};
}`);
		}

		// Generate CSS for all other triggers (including manual animations)
		for (const trigger of otherTriggers) {
			const css = toCSS(trigger, devices, allTriggers, animationLibrary, inputLibrary);
			if (css) {
				cssRules.push(css);
			}
		}

		return cssRules.join('\n\n');
	}	/**
	 * Deserialize trigger data from storage
	 * @param {Object} triggerData - Serialized trigger data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(triggerData, index) {
		// Normalize actionType: 'setValue' -> 'values'
		let actionType = triggerData.actionType;
		if (actionType === 'setValue') {
			actionType = 'values';
		}
		
		return {
			id: triggerData.id || crypto.randomUUID(),
			triggerType: triggerData.triggerType,
			inputId: triggerData.inputId,
			actionType,
			deviceId: triggerData.deviceId,
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: triggerData.animation?.id || triggerData.animationName || null, // Support old animationName
				duration: triggerData.animation?.duration || triggerData.duration || 1000,
				easing: triggerData.animation?.easing || triggerData.easing || 'linear',
				iterations: triggerData.animation?.iterations || triggerData.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			values: actionType === 'values' ? {
				channelValues: triggerData.values?.channelValues || triggerData.channelValues || {},
				enabledControls: triggerData.values?.enabledControls || triggerData.enabledControls || []
			} : null,
			order: triggerData.order !== undefined ? triggerData.order : index
		};
	}
}