/**
 * TriggerLibrary - Reactive Svelte 5 library for managing triggers
 *
 * Extends Library base class with trigger-specific functionality.
 * Stores triggers as plain objects (not class instances) for proper reactivity.
 * Trigger values are stored as control-based objects (NEW ARCHITECTURE).
 */

import { Library } from './Library.svelte.js';
import { generateCSSTriggers } from './triggers/css.js';
import { createDefaultControlValues } from './outputs/controls.js';
import { DEVICE_TYPES } from './outputs/devices.js';

export class TriggerLibrary extends Library {
	constructor() {
		super('dmx-triggers');
	}

	/**
	 * Create and add a new trigger
	 * @param {Object} config - Trigger configuration
	 * @returns {Object} Created trigger object
	 */
	create(config = {}) {
		const triggerType = config.triggerType || 'pressed';
		const actionType = config.actionType || 'animation';

		const trigger = {
			// id will be auto-generated by base class
			triggerType,
			inputId: config.inputId || null, // Links to InputLibrary item
			actionType,
			deviceId: config.deviceId || null, // Single device for both animation and values
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: config.animation?.id || null,
				duration: config.animation?.duration || 1000,
				easing: config.animation?.easing || 'linear',
				iterations: config.animation?.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			// NEW: Control-based values object { "Color": { r, g, b }, "Dimmer": 255, ... }
			// Presence of a control in the object indicates it's enabled
			values: actionType === 'values' ? (config.values || {}) : null,
			order: this.items.length
		};

		return this.add(trigger);
	}


	/**
	 * Generate CSS for all triggers
	 * @param {Array} devices - Array of device objects
	 * @param {Object} animationLibrary - AnimationLibrary instance to resolve animation cssNames
	 * @param {Object} inputLibrary - InputLibrary instance to resolve input names
	 * @returns {string} Combined CSS
	 */
	toCSS(devices = [], animationLibrary = null, inputLibrary = null) {
		const allTriggers = this.getAll();
		
		// Get unique device IDs that are used in triggers
		const deviceIds = new Set(allTriggers.map(t => t.deviceId).filter(id => id));
		
		// Generate CSS for each device
		const cssRules = [];
		for (const deviceId of deviceIds) {
			const device = devices.find(d => d.id === deviceId);
			if (!device) continue;
			
			const css = generateCSSTriggers(device, allTriggers, animationLibrary, inputLibrary);
			if (css) cssRules.push(css);
		}
		
		return cssRules.join('\n\n');
	}	/**
	 * Deserialize trigger data from storage
	 * @param {Object} triggerData - Serialized trigger data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(triggerData, index) {
		const actionType = triggerData.actionType || 'animation';

		// Handle values deserialization
		let values = null;
		if (actionType === 'values') {
			// Check if old format (with channelValues and enabledControls)
			if (triggerData.values?.channelValues || triggerData.channelValues) {
				// OLD FORMAT: Convert from channelValues to control values
				// For now, just reset to defaults (no users to migrate)
				if (triggerData.deviceId) {
					const device = DEVICE_TYPES[triggerData.deviceType];
					if (device) {
						values = createDefaultControlValues(device);
						console.log(`Migrated trigger values from old format to control values`);
					} else {
						values = {};
					}
				} else {
					values = {};
				}
			} else {
				// NEW FORMAT: Control-based values - deep copy
				values = {};
				const sourceValues = triggerData.values || {};
				for (const [key, value] of Object.entries(sourceValues)) {
					if (typeof value === 'object' && value !== null) {
						values[key] = { ...value };
					} else {
						values[key] = value;
					}
				}
			}
		}

		return {
			id: triggerData.id || crypto.randomUUID(),
			triggerType: triggerData.triggerType,
			inputId: triggerData.inputId,
			actionType,
			deviceId: triggerData.deviceId,
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: triggerData.animation?.id || triggerData.animationName || null, // Support old animationName
				duration: triggerData.animation?.duration || triggerData.duration || 1000,
				easing: triggerData.animation?.easing || triggerData.easing || 'linear',
				iterations: triggerData.animation?.iterations || triggerData.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			values,
			order: triggerData.order !== undefined ? triggerData.order : index
		};
	}
}