/**
 * TriggerLibrary - Reactive Svelte 5 library for managing triggers
 *
 * Extends Library base class with trigger-specific functionality.
 * Stores triggers as plain objects (not class instances) for proper reactivity.
 * Trigger values are stored as control-based objects (NEW ARCHITECTURE).
 *
 * Trigger Types:
 * - 'pressed' / 'not-pressed' / 'always': Traditional triggers (animation or static values)
 * - 'value': Value-based triggers that map input values to control values continuously
 */

import { Library } from './Library.svelte.js';
import { generateCSSTriggers, generateValueTriggersCSS } from './triggers/css.js';

export class TriggerLibrary extends Library {
	constructor() {
		super('dmx-triggers');
	}

	/**
	 * Create and add a new trigger
	 * @param {Object} config - Trigger configuration
	 * @returns {Object} Created trigger object
	 */
	create(config = {}) {
		const triggerType = config.triggerType || 'pressed';

		// Value triggers have their own structure
		if (triggerType === 'value') {
			return this._createValueTrigger(config);
		}

		const actionType = config.actionType || 'animation';

		const trigger = {
			// id will be auto-generated by base class
			triggerType,
			inputId: config.inputId || null, // Links to InputLibrary item
			actionType,
			deviceId: config.deviceId || null, // Single device for both animation and values
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: config.animation?.id || null,
				duration: config.animation?.duration || 1000,
				easing: config.animation?.easing || 'linear',
				iterations: config.animation?.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			// NEW: Control-based values object { "Color": { r, g, b }, "Dimmer": 255, ... }
			// Presence of a control in the object indicates it's enabled
			values: actionType === 'values' ? (config.values || {}) : null,
			order: this.items.length
		};

		return this.add(trigger);
	}

	/**
	 * Create a value-based trigger
	 * @private
	 */
	_createValueTrigger(config) {
		const trigger = {
			triggerType: 'value',
			// Input source
			inputId: config.inputId || null,
			inputValueKey: config.inputValueKey || 'value', // Which value from input (value, pressure, etc.)
			// Output target
			deviceId: config.deviceId || null,
			controlId: config.controlId || null, // Target control type id (e.g., 'color', 'dimmer', 'pantilt')
			controlValueId: config.controlValueId || null, // For multi-value controls: 'x', 'y', 'red', 'green', 'blue' (value id)
			// Optional range overrides
			inputMin: config.inputMin ?? null,
			inputMax: config.inputMax ?? null,
			outputMin: config.outputMin ?? null,
			outputMax: config.outputMax ?? null,
			invert: config.invert || false,
			order: this.items.length
		};

		return this.add(trigger);
	}


	/**
	 * Generate CSS for all triggers
	 * @param {Array} devices - Array of device objects
	 * @param {Object} animationLibrary - AnimationLibrary instance to resolve animation cssNames
	 * @param {Object} inputLibrary - InputLibrary instance to resolve input names
	 * @returns {string} Combined CSS
	 */
	toCSS(devices = [], animationLibrary = null, inputLibrary = null) {
		const allTriggers = this.getAll();

		// Separate value triggers from other triggers
		const valueTriggers = allTriggers.filter(t => t.triggerType === 'value');
		const otherTriggers = allTriggers.filter(t => t.triggerType !== 'value');

		// Get unique device IDs that are used in non-value triggers
		const deviceIds = new Set(otherTriggers.map(t => t.deviceId).filter(id => id));

		// Generate CSS for each device (traditional triggers)
		const cssRules = [];
		for (const deviceId of deviceIds) {
			const device = devices.find(d => d.id === deviceId);
			if (!device) continue;

			const css = generateCSSTriggers(device, otherTriggers, animationLibrary, inputLibrary);
			if (css) cssRules.push(css);
		}

		// Generate CSS for value-based triggers (grouped by device)
		const valueDeviceIds = new Set(valueTriggers.map(t => t.deviceId).filter(id => id));
		for (const deviceId of valueDeviceIds) {
			const device = devices.find(d => d.id === deviceId);
			if (!device) continue;

			const deviceValueTriggers = valueTriggers.filter(t => t.deviceId === deviceId);
			const css = generateValueTriggersCSS(deviceValueTriggers, device, inputLibrary);
			if (css) cssRules.push(css);
		}

		return cssRules.join('\n\n');
	}

	/**
	 * Deserialize trigger data from storage
	 * @param {Object} triggerData - Serialized trigger data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(triggerData, index) {
		// Handle value-based triggers
		if (triggerData.triggerType === 'value') {
			return {
				id: triggerData.id || crypto.randomUUID(),
				triggerType: 'value',
				inputId: triggerData.inputId || null,
				inputValueKey: triggerData.inputValueKey || 'value',
				deviceId: triggerData.deviceId || null,
				controlId: triggerData.controlId || triggerData.controlName || null, // Support old 'controlName' for migration
				controlValueId: triggerData.controlValueId || triggerData.controlChannel || null, // Support old 'controlChannel' for migration
				inputMin: triggerData.inputMin ?? null,
				inputMax: triggerData.inputMax ?? null,
				outputMin: triggerData.outputMin ?? null,
				outputMax: triggerData.outputMax ?? null,
				invert: triggerData.invert || false,
				order: triggerData.order !== undefined ? triggerData.order : index
			};
		}

		const actionType = triggerData.actionType || 'animation';

		// Handle values deserialization with deep copy
		let values = null;
		if (actionType === 'values') {
			values = {};
			const sourceValues = triggerData.values || {};
			for (const [key, value] of Object.entries(sourceValues)) {
				if (typeof value === 'object' && value !== null) {
					values[key] = { ...value };
				} else {
					values[key] = value;
				}
			}
		}

		return {
			id: triggerData.id || crypto.randomUUID(),
			triggerType: triggerData.triggerType,
			inputId: triggerData.inputId,
			actionType,
			deviceId: triggerData.deviceId,
			// Animation properties (null for values triggers)
			animation: actionType === 'animation' ? {
				id: triggerData.animation?.id || triggerData.animationName || null, // Support old animationName
				duration: triggerData.animation?.duration || triggerData.duration || 1000,
				easing: triggerData.animation?.easing || triggerData.easing || 'linear',
				iterations: triggerData.animation?.iterations || triggerData.iterations || 1
			} : null,
			// Values properties (null for animation triggers)
			values,
			order: triggerData.order !== undefined ? triggerData.order : index
		};
	}
}