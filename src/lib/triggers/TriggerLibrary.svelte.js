/**
 * TriggerLibrary - Reactive Svelte 5 library for managing triggers
 *
 * Extends Library base class with trigger-specific functionality.
 * Stores triggers as plain objects (not class instances) for proper reactivity.
 */

import { Library } from '../Library.svelte.js';
import { Trigger } from '../triggers.js';

export class TriggerLibrary extends Library {
	constructor() {
		super('webdmx-triggers');
	}

	/**
	 * Create and add a new trigger
	 * @param {Object} config - Trigger configuration
	 * @returns {Object} Created trigger object
	 */
	create(config = {}) {
		const triggerType = config.triggerType || 'pressed';

		// Generate CSS class name
		const cssClassName = config.cssClassName || Trigger.generateClassName({
			triggerType,
			inputDeviceId: config.inputDeviceId,
			inputControlId: config.inputControlId,
			id: null // Will be generated by base class
		});

		const trigger = {
			// id will be auto-generated by base class
			triggerType,
			inputDeviceId: config.inputDeviceId || null,
			inputControlId: config.inputControlId || null,
			actionType: config.actionType || 'animation',
			animationName: config.animationName || null,
			targetDeviceIds: config.targetDeviceIds || [],
			duration: config.duration || 1000,
			easing: config.easing || 'linear',
			iterations: config.iterations || 1,
			setValueDeviceId: config.setValueDeviceId || null,
			channelValues: config.channelValues || {},
			enabledControls: config.enabledControls || [],
			cssClassName,
			order: this.items.length
		};

		return this.add(trigger);
	}



	/**
	 * Update trigger properties
	 * @param {string} id - Trigger ID
	 * @param {Object} updates - Properties to update
	 * @returns {boolean} Success status
	 */
	update(id, updates) {
		const trigger = this.get(id);
		if (!trigger) return false;

		// Apply updates
		Object.assign(trigger, updates);

		// Update CSS class name if input or trigger type changed
		if (updates.inputDeviceId !== undefined ||
		    updates.inputControlId !== undefined ||
		    updates.triggerType !== undefined) {
			trigger.cssClassName = Trigger.generateClassName(trigger);
		}

		this.save();
		return true;
	}

	/**
	 * Generate CSS for all triggers
	 * @param {Array} devices - Array of device objects
	 * @returns {string} Combined CSS
	 */
	toCSS(devices = []) {
		const allTriggers = this.getAll();
		const cssRules = [];

		// Group automatic animation triggers by device to combine them
		const automaticAnimationsByDevice = new Map(); // deviceId -> array of triggers

		// Separate automatic animations from other triggers
		const automaticAnimations = [];
		const otherTriggers = [];

		for (const trigger of allTriggers) {
			if (trigger.actionType === 'animation' &&
			    trigger.triggerType === 'always' &&
			    trigger.animationName) {
				automaticAnimations.push(trigger);
			} else {
				otherTriggers.push(trigger);
			}
		}

		// Group automatic animations by device
		for (const trigger of automaticAnimations) {
			for (const deviceId of trigger.targetDeviceIds) {
				if (!automaticAnimationsByDevice.has(deviceId)) {
					automaticAnimationsByDevice.set(deviceId, []);
				}
				automaticAnimationsByDevice.get(deviceId).push(trigger);
			}
		}

		// Generate combined CSS for automatic animations
		for (const [deviceId, triggers] of automaticAnimationsByDevice.entries()) {
			const device = devices.find(d => d.id === deviceId);
			if (!device) continue;

			// Combine all automatic animations for this device
			const animationSpecs = triggers.map(trigger => {
				const iterVal = trigger.iterations === 'infinite' ? 'infinite' : trigger.iterations;
				const durSec = (trigger.duration / 1000).toFixed(3);
				return `${trigger.animationName} ${durSec}s ${trigger.easing} ${iterVal}`;
			});

			const animationValue = animationSpecs.join(', ');
			cssRules.push(`#${device.cssId} {
  animation: ${animationValue};
}`);
		}

		// Generate CSS for all other triggers (including manual animations)
		for (const trigger of otherTriggers) {
			const css = Trigger.toCSS(trigger, devices, allTriggers);
			if (css) {
				cssRules.push(css);
			}
		}

		return cssRules.join('\n\n');
	}

	/**
	 * Deserialize trigger data from storage
	 * @param {Object} triggerData - Serialized trigger data
	 * @param {number} index - Array index for order
	 */
	deserializeItem(triggerData, index) {
		// Ensure ID exists (generate UUID if missing for old data)
		return {
			id: triggerData.id || crypto.randomUUID(),
			triggerType: triggerData.triggerType,
			inputDeviceId: triggerData.inputDeviceId,
			inputControlId: triggerData.inputControlId,
			actionType: triggerData.actionType,
			animationName: triggerData.animationName,
			targetDeviceIds: triggerData.targetDeviceIds,
			duration: triggerData.duration,
			easing: triggerData.easing,
			iterations: triggerData.iterations,
			setValueDeviceId: triggerData.setValueDeviceId,
			channelValues: triggerData.channelValues,
			enabledControls: triggerData.enabledControls,
			cssClassName: triggerData.cssClassName,
			order: triggerData.order !== undefined ? triggerData.order : index
		};
	}
}